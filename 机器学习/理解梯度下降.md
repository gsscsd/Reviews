**\*导言***

最优化问题在机器学习中有非常重要的地位，很多机器学习算法最后都归结为求解最优化问题。在各种最优化算法中，梯度下降法是最简单、最常见的一种，在深度学习的训练中被广为使用。在本文中，[SIGAI](http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&mid=2247484037&idx=2&sn=82d761ec0765fb79cb491906e76acc52&chksm=fdb69f12cac11604db50c9bd8665094d3da6e368501588bf264b1777db6e1369483fd795fe98&scene=21#wechat_redirect)将为大家系统的讲述梯度下降法的原理和实现细节问题。

![img](https://mmbiz.qpic.cn/mmbiz_jpg/75DkJnThACmbZyH56TS9jKRokzZHIsGC2KHnpZxCo68fyuaJzMn8dz2EVoIyjdG1ptibHMdMwRiauya1nOYFY2KQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

###  最优化问题

最优化问题是求解函数极值的问题，包括极大值和极小值。相信所有的读者对这个问题都不陌生，在初中时我们就学会了求解二次函数的极值（抛物线的顶点），高中时学习了幂函数，指数函数，对数函数，三角函数，反三角函数等各种类型的函数，求函数极值的题更是频频出现。这些方法都采用了各种各样的技巧，没有一个统一的方案。

真正的飞跃发生在大学时，微积分为我们求函数的极值提供了一个统一的思路：找函数的导数等于0的点，因为在极值点处，导数必定为0。这样，只要函数的可导的，我们就可以用这个万能的方法解决问题，幸运的是，在实际应用中我们遇到的函数基本上都是可导的。

在机器学习之类的实际应用中，我们一般将最优化问题统一表述为求解函数的极小值问题，即：

![img](https://mmbiz.qpic.cn/mmbiz_jpg/75DkJnThACmbZyH56TS9jKRokzZHIsGCeKLcjY2IP6KtfvgIVMuIjITJqYvibcicUXwOrgYGwllQM3zicpWebsXBQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

其中x称为优化变量，f称为目标函数。极大值问题可以转换成极小值问题来求解，只需要将目标函数加上负号即可：

![img](https://mmbiz.qpic.cn/mmbiz_jpg/75DkJnThACmbZyH56TS9jKRokzZHIsGCQ8TPwhsib34j7ulluATJX4byd5xUOLQqqEPm738zg42RShibO9grAWXA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

有些时候会对优化变量x有约束，包括等式约束和不等式约束，它们定义了优化变量的可行域，即满足约束条件的点构成的集合。在这里我们先不考虑带约束条件的问题。

一个优化问题的全局极小值![\      x^{*}   ](https://mmbiz.qpic.cn/mmbiz_png/75DkJnThACmbZyH56TS9jKRokzZHIsGC1mZ2fj8z91mOD1wUZOScLtMgsOic48Dmmfa4ib5Gp6ZrMoPnL7pVZmBA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)是指对于可行域里所有的x，有：

![img](https://mmbiz.qpic.cn/mmbiz_jpg/75DkJnThACmbZyH56TS9jKRokzZHIsGCk3CVXu0WTezmubttlPH14qkUnDOTIZANpVsGhGhfVyv34kB1eAj2qQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

即全局极小值点处的函数值不大于任意一点处的函数值。局部极小值![\      x^{*}   ](https://mmbiz.qpic.cn/mmbiz_png/75DkJnThACmbZyH56TS9jKRokzZHIsGC1mZ2fj8z91mOD1wUZOScLtMgsOic48Dmmfa4ib5Gp6ZrMoPnL7pVZmBA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)定义为存在一个![\     \delta   ](https://mmbiz.qpic.cn/mmbiz_png/75DkJnThACmbZyH56TS9jKRokzZHIsGC661laYe8sE22G5ujVypPA0ibMzccDtbrIxvqCtK1XmhrJoiawwHFrf0A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)邻域，对于在邻域内：

![img](https://mmbiz.qpic.cn/mmbiz_jpg/75DkJnThACmbZyH56TS9jKRokzZHIsGCfzqOiafSrnqicQsDBE9mXaHS2wQQ21RtLAQbuias68iagyA6BNibSg9icMrQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

并且在可行域内的所有x，有：

![img](https://mmbiz.qpic.cn/mmbiz_jpg/75DkJnThACmbZyH56TS9jKRokzZHIsGClhtokXNibic5XWM0ZAnAwx7Kcib2BDC4bE5KrrjhRKR5vcgUpXtnzZqhg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

即局部极小值点处的函数值比一个局部返回内所有点的函数值都小。在这里，我们的目标是找到全局极小值。不幸的是，有些函数可能有多个局部极小值点，因此即使找到了导数等于0的所有点，还需要比较这些点处的函数值。

### 导数与梯度

由于实际应用中一般都是多元函数，因此我们跳过一元函数，直接介绍多元函数的情况。梯度是导数对多元函数的推广，它是多元函数对各个自变量偏导数形成的向量。多元函数的梯度定义为：

![img](https://mmbiz.qpic.cn/mmbiz_jpg/75DkJnThACmbZyH56TS9jKRokzZHIsGCeS9iaAC8YjlQd9ho0Lo7Bun4WMWERCAqFGeIYG68TbgUlydlKbVKYqA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

其中$\delta$称为梯度算子，它作用于一个多元函数，得到一个向量。下面是计算函数梯度的一个例子：

![img](https://mmbiz.qpic.cn/mmbiz_jpg/75DkJnThACmbZyH56TS9jKRokzZHIsGC5G9QvIcN3df2RsmMd3PqVibbupkzZc9Hoq6iaIDZHLOyGvKXnK8hPB9w/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

可导函数在某一点处取得极值的必要条件是梯度为0，梯度为0的点称为函数的驻点，这是疑似极值点。需要注意的是，梯度为0只是函数取极值的必要条件而不是充分条件，即梯度为0的点可能不是极值点。

至于是极大值还是极小值，要看二阶导数/Hessian矩阵，Hessian矩阵我们将在后面的文章中介绍，这是由函数的二阶偏导数构成的矩阵。这分为下面几种情况：

**如果Hessian矩阵正定，函数有极小值**

**如果Hessian矩阵负定，函数有极大值**

**如果Hessian矩阵不定，则需要进一步讨论**

这和一元函数的结果类似，Hessian矩阵可以看做是一元函数的二阶导数对多元函数的推广。一元函数的极值判别法为，假设在某点处导数等于0，则：

**如果二阶导数大于0，函数有极小值**

**如果二阶导数小于0，函数有极大值**

**如果二阶导数等于0，情况不定**

在这里我们可能会问：直接求函数的导数/梯度，然后令导数/梯度为0，解方程，问题不就解决了吗？事实上没这么简单，因为这个方程可能很难解。比如下面的函数：

![img](https://mmbiz.qpic.cn/mmbiz_jpg/75DkJnThACmbZyH56TS9jKRokzZHIsGCxpTl6Fic50kJRyZok7V7led7jRlYFcsTPxMaTUeiaEyIiaKwVjccHH5IQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

我们分别对x和y求偏导数，并令它们为0，得到下面的方程组：

![img](https://mmbiz.qpic.cn/mmbiz_jpg/75DkJnThACmbZyH56TS9jKRokzZHIsGCtGralHvuzNiacuRF8icnBic7y6KlIul9emENxrlMc1wviaorJUWZbkmcEQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

这个方程非常难以求解，对于有指数函数，对数函数，三角函数的方程，我们称为超越方程，求解的难度并不比求极值本身小。

 

精确的求解不太可能，因此只能求近似解，这称为数值计算。工程上实现时通常采用的是迭代法，它从一个初始点![\      x_{0}  ](https://mmbiz.qpic.cn/mmbiz_png/75DkJnThACmbZyH56TS9jKRokzZHIsGCb5P9YEgNmGw3AvK2tblA9rwfCdiaNQrLd1SVJkjhwMIa0O5UwFQlrMA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)开始，反复使用某种规则从![\     x_{k}   ](https://mmbiz.qpic.cn/mmbiz_png/75DkJnThACmbZyH56TS9jKRokzZHIsGCrkiaPlH7nCwJZCMmBDBwvC7wZchtdPXRs5F8KwRbYaGwGuCXHOkyNkQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)移动到下一个点![\      x_{k+1}  ](https://mmbiz.qpic.cn/mmbiz_png/75DkJnThACmbZyH56TS9jKRokzZHIsGCQKB9DKsicVHhcLlvicqJnHOh74CtEIgVOibOh7eKiaiaibGpibch8T0ibvyC9A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)，构造这样一个数列，直到收敛到梯度为0的点处。即有下面的极限成立：

![img](https://mmbiz.qpic.cn/mmbiz_jpg/75DkJnThACmbZyH56TS9jKRokzZHIsGCR5Lj8E7CxpouaFURu2ggV4vX5JBFhafxFdKqWE4ALicgahaVgdtTmicA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

这些规则一般会利用一阶导数信息即梯度；或者二阶导数信息即Hessian矩阵。这样迭代法的核心是得到这样的由上一个点确定下一个点的迭代公式：

![img](https://mmbiz.qpic.cn/mmbiz_jpg/75DkJnThACmbZyH56TS9jKRokzZHIsGChcnialia6O86iczwS4QF4lNdib1CO8lwHhkhwIyR2Nia4B5lQZvJibq6gZpg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

这个过程就像我们处于山上的某一位置，要到山底找水喝，因此我们必须到达最低点处：

![img](https://mmbiz.qpic.cn/mmbiz_png/75DkJnThACmbZyH56TS9jKRokzZHIsGC6pgfzSwUAVLcUaqFbrPcmEnJ4dhN0yxmRvajia54cIav2GpEP0SAdFg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

此时我们没有全局信息，根本就不知道哪里是地势最低的点，只能想办法往山下走，走 一步看一步。刚开始我们在山上的某一点处，每一步，我们都往地势更低的点走，以期望能走到山底。

### 推导过程

首先我们来看一元函数的泰勒展开，以便于更好的理解多元函数的泰勒展开。如果一个一元函数n阶可导，它的泰勒展开公式为：

![img](https://mmbiz.qpic.cn/mmbiz_jpg/75DkJnThACmbZyH56TS9jKRokzZHIsGCXjZQYWgmqFwOEjibt08YPWxfx5TibEvhrRGM2g4kcwLAf2SD92wtoiarQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

如果在某一点处导数值大于0（+），则函数在此处是增函数，加大x的值函数值会增加，减小x的值（-）函数会减小。相反的，如果在某一点处导数值小于0（-），则函数是减函数，增加x的值函数值会减小（+），减小x的值函数会增加。因此我们可以得出一个结论：如果x的变化很小，并且变化值与导数值反号，则函数值下降。对于一元函数，x的变化只有两个方向，要么朝左，要么朝右。

 

下面我们把这一结论推广到多元函数的情况。多元函数![\     f(x)   ](https://mmbiz.qpic.cn/mmbiz_png/75DkJnThACmbZyH56TS9jKRokzZHIsGCFrLzWVQMBf4wgiaZcRcfU15AUHic0PtEg0La3G0jCGbmSe2icgPHzcQSg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)在x点处的泰勒展开为：

![img](https://mmbiz.qpic.cn/mmbiz_jpg/75DkJnThACmbZyH56TS9jKRokzZHIsGCxdCR7ZtfNwV8kvwibiaWNzbOtvdCDzDFmkRr2783dM5YdH5ISktUnSRw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

这里我们忽略了二次及更高的项。其中，一次项是梯度向量![img](https://mmbiz.qpic.cn/mmbiz_jpg/75DkJnThACmbZyH56TS9jKRokzZHIsGCbDYIq35j06CRk7Qh4UCpnBmAEGO5WicSzhDJtWxibz0QMdlNJXljUQvg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)与自变量增量![\     \Delta x   ](https://mmbiz.qpic.cn/mmbiz_png/75DkJnThACmbZyH56TS9jKRokzZHIsGCYSFCcvSJ7Eunpba4OMJ8BV2JuHvFTxxmLDt5O80ic0jd4o5StGaNW0g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)的内积![img](https://mmbiz.qpic.cn/mmbiz_jpg/75DkJnThACmbZyH56TS9jKRokzZHIsGClBOia6hEDIrVmYpibJDUvGo1dUpqteOwo66icMPUicfK3btpDOuq3qVfQg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)，这等价于一元函数的![\     f^{'}(x_{0})(x-x_{0})   ](https://mmbiz.qpic.cn/mmbiz_png/75DkJnThACmbZyH56TS9jKRokzZHIsGC98kUspQnxI33EW7FVGFYvts1OPAwD4mkYxodXLJSKKmqm8rWT8BePw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)。这样，函数的增量与自变量的增量![\     \Delta x   ](https://mmbiz.qpic.cn/mmbiz_png/75DkJnThACmbZyH56TS9jKRokzZHIsGCYSFCcvSJ7Eunpba4OMJ8BV2JuHvFTxxmLDt5O80ic0jd4o5StGaNW0g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)、函数梯度的关系可以表示为：

![img](https://mmbiz.qpic.cn/mmbiz_jpg/75DkJnThACmbZyH56TS9jKRokzZHIsGCV0ZpXkXb2cIAMp9viby1HZz667NnzaUyXrRXaialCxPjTXgWWiczqyVnw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

如果![\     \Delta x   ](https://mmbiz.qpic.cn/mmbiz_png/75DkJnThACmbZyH56TS9jKRokzZHIsGCYSFCcvSJ7Eunpba4OMJ8BV2JuHvFTxxmLDt5O80ic0jd4o5StGaNW0g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)足够小，在x的某一邻域内，则我们可以忽略二次及以上的项，有：

![img](https://mmbiz.qpic.cn/mmbiz_jpg/75DkJnThACmbZyH56TS9jKRokzZHIsGC0ogdD7rl1vk2AeLuictHjxW74rAb2aJsxK2pHlRsjUDrOTaruD4icX0w/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

这里的情况比一元函数复杂多了，![\     \Delta x   ](https://mmbiz.qpic.cn/mmbiz_png/75DkJnThACmbZyH56TS9jKRokzZHIsGCYSFCcvSJ7Eunpba4OMJ8BV2JuHvFTxxmLDt5O80ic0jd4o5StGaNW0g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)是一个向量，![\     \Delta x   ](https://mmbiz.qpic.cn/mmbiz_png/75DkJnThACmbZyH56TS9jKRokzZHIsGCYSFCcvSJ7Eunpba4OMJ8BV2JuHvFTxxmLDt5O80ic0jd4o5StGaNW0g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)有无穷多种方向，该往哪个方向走呢？如果能保证：

![img](https://mmbiz.qpic.cn/mmbiz_jpg/75DkJnThACmbZyH56TS9jKRokzZHIsGCKeMHNBDWFk1Ykw7Xld44kg7gibrictiaMOmbG5iaNBc6lh2TYu3DzY1KJg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

则有：

![img](https://mmbiz.qpic.cn/mmbiz_jpg/75DkJnThACmbZyH56TS9jKRokzZHIsGCXPQa7TpoicblqGGqXgsIiceKjeS9QJibq6xnbEBwdB7LJ89IwgTHqsb2w/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

即函数值递减，这就是下山的正确方向。因为有：

![img](https://mmbiz.qpic.cn/mmbiz_jpg/75DkJnThACmbZyH56TS9jKRokzZHIsGCibbUPAt9INj4v684zOtQoXP3dicROGCVUHIwnLlbCqZ1dktiaHiaE16yxA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

在这里，||·||表示向量的模，![\    \theta    ](https://mmbiz.qpic.cn/mmbiz_png/75DkJnThACmbZyH56TS9jKRokzZHIsGCoQ4v812vQt2aJfI7yONbXj7VwiavJDkiaibBQKlemFo8ttjiaP20XNSqcg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)是向量![img](https://mmbiz.qpic.cn/mmbiz_jpg/75DkJnThACmbZyH56TS9jKRokzZHIsGCbDYIq35j06CRk7Qh4UCpnBmAEGO5WicSzhDJtWxibz0QMdlNJXljUQvg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)和![\     \Delta x   ](https://mmbiz.qpic.cn/mmbiz_png/75DkJnThACmbZyH56TS9jKRokzZHIsGCYSFCcvSJ7Eunpba4OMJ8BV2JuHvFTxxmLDt5O80ic0jd4o5StGaNW0g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)的夹角。因为向量的模一定大于等于0，如果：

![img](https://mmbiz.qpic.cn/mmbiz_jpg/75DkJnThACmbZyH56TS9jKRokzZHIsGCPEherbvKTZ6RbbjFNwOAwfbd1La8cUb40jZ9qXSfkSrEemU1bp7c3Q/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

则能保证：

![img](https://mmbiz.qpic.cn/mmbiz_jpg/75DkJnThACmbZyH56TS9jKRokzZHIsGCvsnicOrud00rdu1IZyA6uAF5WQbJzSJ6W3mbqeticbiaL4tDydqibgicQOw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

即选择合适的增量![\     \Delta x   ](https://mmbiz.qpic.cn/mmbiz_png/75DkJnThACmbZyH56TS9jKRokzZHIsGCYSFCcvSJ7Eunpba4OMJ8BV2JuHvFTxxmLDt5O80ic0jd4o5StGaNW0g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)，就能保证函数值下降，要达到这一目的，只要保证梯度和![\     \Delta x   ](https://mmbiz.qpic.cn/mmbiz_png/75DkJnThACmbZyH56TS9jKRokzZHIsGCYSFCcvSJ7Eunpba4OMJ8BV2JuHvFTxxmLDt5O80ic0jd4o5StGaNW0g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)的夹角的余弦值小于等于0就可以了。由于有：

![img](https://mmbiz.qpic.cn/mmbiz_jpg/75DkJnThACmbZyH56TS9jKRokzZHIsGCyveF6QpxeOCzyMBZDkSNNHDbIkUQpXYIIo9WIDYzE3WoGEfXyazeLg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

只有当：

![img](https://mmbiz.qpic.cn/mmbiz_jpg/75DkJnThACmbZyH56TS9jKRokzZHIsGCLBbQoGNLQUdnVN0ibOsXM7XicHndyxsMc1clffdewRAzmTy1FjqCGbcg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

时![\    cos\theta    ](https://mmbiz.qpic.cn/mmbiz_png/75DkJnThACmbZyH56TS9jKRokzZHIsGCCv6WPZUZX0gURRkCWwmkupBlSn3x9iaOiblSyrQMneoTKDPWsdw70QMg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)有极小值-1，此时梯度和![\     \Delta x   ](https://mmbiz.qpic.cn/mmbiz_png/75DkJnThACmbZyH56TS9jKRokzZHIsGCYSFCcvSJ7Eunpba4OMJ8BV2JuHvFTxxmLDt5O80ic0jd4o5StGaNW0g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)反向，即夹角为180度。因此当向量![\     \Delta x   ](https://mmbiz.qpic.cn/mmbiz_png/75DkJnThACmbZyH56TS9jKRokzZHIsGCYSFCcvSJ7Eunpba4OMJ8BV2JuHvFTxxmLDt5O80ic0jd4o5StGaNW0g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)的模大小一定时，当：

![img](https://mmbiz.qpic.cn/mmbiz_jpg/75DkJnThACmbZyH56TS9jKRokzZHIsGC0JialgTNSKs3FZrKd5qNTPGBJ2TzD6bU0P2aMCE0v02vq6uRtYNUkXA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

即在梯度相反的方向函数值下降的最快。此时有：

![img](https://mmbiz.qpic.cn/mmbiz_jpg/75DkJnThACmbZyH56TS9jKRokzZHIsGCvjgXAIL0qJesadTib8I5KhaaG7Q1icN6mgJRlw7QJbnkAPXuZ7TM8m8Q/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

函数的下降值为：

![img](https://mmbiz.qpic.cn/mmbiz_jpg/75DkJnThACmbZyH56TS9jKRokzZHIsGCKTaZBAhI2kcLeIzp2Uo6LqsxcBJqOpPhjWgGSc88NWvRhibjt8hWiciaA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

只要梯度不为0，往梯度的反方向走函数值一定是下降的。直接用![img](https://mmbiz.qpic.cn/mmbiz_jpg/75DkJnThACmbZyH56TS9jKRokzZHIsGCCIntPH6aMlIMgTbSfxIndq6ohlTMUJRHonlRYetWMH5tOULy76c9OA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)可能会有问题，因为x+![\     \Delta x   ](https://mmbiz.qpic.cn/mmbiz_png/75DkJnThACmbZyH56TS9jKRokzZHIsGCYSFCcvSJ7Eunpba4OMJ8BV2JuHvFTxxmLDt5O80ic0jd4o5StGaNW0g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)可能会超出x的邻域范围之外，此时是不能忽略泰勒展开中的二次及以上的项的，因此步伐不能太大。一般设：

![img](https://mmbiz.qpic.cn/mmbiz_jpg/75DkJnThACmbZyH56TS9jKRokzZHIsGC0JialgTNSKs3FZrKd5qNTPGBJ2TzD6bU0P2aMCE0v02vq6uRtYNUkXA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

其中![\     \alpha   ](https://mmbiz.qpic.cn/mmbiz_png/75DkJnThACmbZyH56TS9jKRokzZHIsGCyKjUjjic3jPaCF2cwDybBVcXYOrkGWU3nRGxUD1FOfgzjG957WxZHdg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)为一个接近于0的正数，称为步长，由人工设定，用于保证x+![\     \Delta x   ](https://mmbiz.qpic.cn/mmbiz_png/75DkJnThACmbZyH56TS9jKRokzZHIsGCYSFCcvSJ7Eunpba4OMJ8BV2JuHvFTxxmLDt5O80ic0jd4o5StGaNW0g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)在x的邻域内，从而可以忽略泰勒展开中二次及更高的项，则有：

![img](https://mmbiz.qpic.cn/mmbiz_jpg/75DkJnThACmbZyH56TS9jKRokzZHIsGC77S7DwUTIBHUicduVRjkXBUQK78UIiccrADgE4wMGLj752UbFk2xOKSw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

从初始点![\      x_{0}  ](https://mmbiz.qpic.cn/mmbiz_png/75DkJnThACmbZyH56TS9jKRokzZHIsGCb5P9YEgNmGw3AvK2tblA9rwfCdiaNQrLd1SVJkjhwMIa0O5UwFQlrMA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)开始，使用如下迭代公式：

![img](https://mmbiz.qpic.cn/mmbiz_jpg/75DkJnThACmbZyH56TS9jKRokzZHIsGCzBaeC9HKTYVccbTPzAicDApGGdHxTjIrjiaIOxf69xQd5ACuL3XibKoJg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

只要没有到达梯度为0的点，则函数值会沿着序列![\     x_{k}   ](https://mmbiz.qpic.cn/mmbiz_png/75DkJnThACmbZyH56TS9jKRokzZHIsGCrkiaPlH7nCwJZCMmBDBwvC7wZchtdPXRs5F8KwRbYaGwGuCXHOkyNkQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)递减，最终会收敛到梯度为0的点，这就是梯度下降法。迭代终止的条件是函数的梯度值为0（实际实现时是接近于0），此时认为已经达到极值点。注意我们找到的是梯度为0的点，这不一定就是极值点，后面会说明。梯度下降法只需要计算函数在某些点处的梯度，实现简单，计算量小。

### 实现细节问题

下面我们介绍梯度下降法实现时的一些细节问题，包括初始值的设定，学习率的设定，下面分别进行介绍。

#### 初始值的设定

一般的，对于不带约束条件的优化问题，我们可以将初始值设置为0，或者设置为随机数，对于神经网络的训练，一般设置为随机数，这对算法的收敛至关重要[1]。

#### 学习率的设定

学习率设置为多少，也是实现时需要考虑的问题。最简单的，我们可以将学习率设置为一个很小的正数，如0.001。另外，可以采用更复杂的策略，在迭代的过程中动态的调整学习率的值。比如前1万次迭代为0.001，接下来1万次迭代时设置为0.0001。

#### 面临的问题

在实现时，梯度下降法可能会遇到一些问题，典型的是局部极小值和鞍点问题，下面分别进行介绍。

#### 局部极小值

有些函数可能有多个局部极小值点，下面是一个例子：

![img](https://mmbiz.qpic.cn/mmbiz_png/75DkJnThACmbZyH56TS9jKRokzZHIsGCsZT3TbZUxkEicddGeU5Mt01M774TjVKicwliaHQt7JHkSI2NWd4kQtWNg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

这张图中的函数有3个局部极值点，分别是A，B和C，但只有A才是全局极小值，梯度下降法可能迭代到B或者C点处就终止。

####     鞍点

鞍点是指梯度为0，Hessian矩阵既不是正定也不是负定，即不定的点。下面是鞍点的一个例子，假设有函数：

![img](https://mmbiz.qpic.cn/mmbiz_jpg/75DkJnThACmbZyH56TS9jKRokzZHIsGCfmQjlu9mdzlUlaUuXNw9UOTbYTxpob3kTuCsOZXPEK6kIiaiczouEU3A/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

显然在(0, 0)这点处不是极值点，但梯度为0，下面是梯度下降法的运行结果：

![img](https://mmbiz.qpic.cn/mmbiz_png/75DkJnThACmbZyH56TS9jKRokzZHIsGC11on7eVwFUCP9RCykxrcA1UIwR0adOdASlgDjpuxwZuHj1BFbEGg0A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

在这里，梯度下降法遇到了鞍点，认为已经找到了极值点，从而终止迭代过程，而这根本不是极值点。

对于怎么逃离局部极小值点和鞍点，有一些解决方案，在这里我们暂时不细讲，以后有机会再专门写文章介绍。对于凸优化问题，不会遇到上面的局部极小值与鞍点问题，即梯度下降法一定能找到全局最优解。凸优化的概念将在[SIGAI](http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&mid=2247484037&idx=2&sn=82d761ec0765fb79cb491906e76acc52&chksm=fdb69f12cac11604db50c9bd8665094d3da6e368501588bf264b1777db6e1369483fd795fe98&scene=21#wechat_redirect)后续的文章中介绍。

#### 变种

梯度下降法有大量的变种，它们都只利用之前迭代时的梯度信息来构造每次的更新值，下面我们分别进行介绍。最直接的改进是为迭代公式加上动量项，动量项累积了之前的权重更新值，加上此项之后的参数更新公式为：

![img](https://mmbiz.qpic.cn/mmbiz_jpg/75DkJnThACmbZyH56TS9jKRokzZHIsGCjJoEolZygQ5zhdGsQG3b4rvEjxwXerRshh8N1FiajhE252JMsmrYmwA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

其中![\    V_{t+1}    ](https://mmbiz.qpic.cn/mmbiz_png/75DkJnThACmbZyH56TS9jKRokzZHIsGCz59CicZnMahxWfpbHUW7ahqDJISMh8yicowcSh3zpjvAdeXY3lpgPXhA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)是动量项，它取代了之前的梯度项。动量项的计算公式为：

![img](https://mmbiz.qpic.cn/mmbiz_jpg/75DkJnThACmbZyH56TS9jKRokzZHIsGCQzrQrt5ghYB87qvuichoiaJFhibmeWk7d36p7a4kudoZ89cX2tDAicAMFQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

动量项累积了之前的梯度信息，类似于保持行走时的惯性，以避免来回震荡，加快收敛速度。

AdaGrad为自适应梯度，即adaptive gradient算法[2]，是梯度下降法最直接的改进。唯一不同的是，AdaGrad根据前几轮迭代时的历史梯度值来调整学习率，参数更新公式为：

![img](https://mmbiz.qpic.cn/mmbiz_jpg/75DkJnThACmbZyH56TS9jKRokzZHIsGC8fc0cB6avlqrxSC0hnBO1q98tiaOPyJuqck4EZDuJqoMHCZ2yKuGP2w/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

其中![\     \alpha   ](https://mmbiz.qpic.cn/mmbiz_png/75DkJnThACmbZyH56TS9jKRokzZHIsGCyKjUjjic3jPaCF2cwDybBVcXYOrkGWU3nRGxUD1FOfgzjG957WxZHdg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)是学习因子，![\    g_{t}    ](https://mmbiz.qpic.cn/mmbiz_png/75DkJnThACmbZyH56TS9jKRokzZHIsGCkaGmRYv3bdXPEG04szKyias2YU5NsSSJVOGPlJlHgLLwq7EZYHQb8uQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)是第t次迭代时的参数梯度向量，![\     \varepsilon   ](https://mmbiz.qpic.cn/mmbiz_png/75DkJnThACmbZyH56TS9jKRokzZHIsGCtEyDSooy7v13WQ1fCpctWTtAQFHXRDl072MaNiazA4m987dzg8XX2Zw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)是一个很小的正数，为了避免除0操作，下标i表示向量的分量。和标准梯度下降法唯一不同的是多了分母中的这一项，它累积了到本次迭代为止梯度的历史值信息用于生成梯度下降的系数值。

 

AdaDelta算法[3]也是梯度下降法的变种，在每次迭代时也利用梯度值构造参数的更新值。假设要优化的参数为x，梯度下降法第t次迭代时计算出来的参数梯度值为![\    g_{t}    ](https://mmbiz.qpic.cn/mmbiz_png/75DkJnThACmbZyH56TS9jKRokzZHIsGCkaGmRYv3bdXPEG04szKyias2YU5NsSSJVOGPlJlHgLLwq7EZYHQb8uQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)。算法首先初始化如下两个向量为0向量：

![img](https://mmbiz.qpic.cn/mmbiz_jpg/75DkJnThACmbZyH56TS9jKRokzZHIsGCguo5sSTVse0icvOsHLcVPcsN0CibA61oictssqywkY9swhzWEveWN784g/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

其中![\    E[g^{2}]    ](https://mmbiz.qpic.cn/mmbiz_png/75DkJnThACmbZyH56TS9jKRokzZHIsGCrn0ALAYqh3dMXnkPIyJia8DwvKEg5ZdQDLBsK4dpH9eK5SpG8OjST6g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)是梯度平方（对每个分量分别平分）的累计值，更新公式为：

![img](https://mmbiz.qpic.cn/mmbiz_jpg/75DkJnThACmbZyH56TS9jKRokzZHIsGClBnSDQWt6iaiaVAaPMuiagbbpKuGC99Sia5Lhib4H7zQtMxJMrHNQ28vBuw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

在这里![\    g^{2}    ](https://mmbiz.qpic.cn/mmbiz_png/75DkJnThACmbZyH56TS9jKRokzZHIsGCicq33ibRNRd2cn7Ic8oUSmecAyRVErZ8Ee2ERriaxWhOU2fMM2Zn7W7SA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)是向量每个元素分别计算平方，后面所有的计算公式都是对向量的每个分量进行。接下来计算如下RMS量：

![img](https://mmbiz.qpic.cn/mmbiz_jpg/75DkJnThACmbZyH56TS9jKRokzZHIsGCiaOjHibauDYH8y6KZcibYbdKEpmxTnpw0GiaprPZ3RxToHgxd1288Zl94g/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

这也是一个向量，计算时分别对向量的每个分量进行。然后计算参数的更新值：

![img](https://mmbiz.qpic.cn/mmbiz_jpg/75DkJnThACmbZyH56TS9jKRokzZHIsGC4uNGsDJuG0UyicqgIpEB9aFKiaKuYAJKXwMbl158vibScHXbto5qGvpSg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

![img](https://mmbiz.qpic.cn/mmbiz_jpg/75DkJnThACmbZyH56TS9jKRokzZHIsGCP1Igib8ZCSRibW8dB7RSugs3UlI9ia7YWicf9SgNs4D2E2aNK1DSwGCZpA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)的计算公式和这个类似。这个更新值同样通过梯度来构造，只不过学习率是通过梯度的历史值确定的。更新公式为：

![img](https://mmbiz.qpic.cn/mmbiz_jpg/75DkJnThACmbZyH56TS9jKRokzZHIsGCDsLg1BIdNKbqvichzL0fBcNlNxha2arBmV36YgLjWK9XpZyhKeeaLSg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

参数更新的迭代公式为：

![img](https://mmbiz.qpic.cn/mmbiz_jpg/75DkJnThACmbZyH56TS9jKRokzZHIsGCGIwibMVUMrJibfd3Y7D7HQ0OgW0RUTZvRQsqx0AhuP69IyFibN8OH0mBA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

和带动量项的梯度下降法不同的是这里用历史梯度值来构造学习率，包括了梯度的平方值。

 

Adam算法[4]全称为adaptive moment estimation，它由梯度项构造了两个向量m和v，它们的初始值为0，更新公式为：

![img](https://mmbiz.qpic.cn/mmbiz_jpg/75DkJnThACmbZyH56TS9jKRokzZHIsGCj4ns3HQqbEERfdWqVicMGFlPkNicqibYDIeR240s1dvNDSfhg18xPIDTA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

![img](https://mmbiz.qpic.cn/mmbiz_jpg/75DkJnThACmbZyH56TS9jKRokzZHIsGCvp5Zib760X2Q7nzb3UIJkLXctDcCw9Dd193MyLMTX7jTh8a1BicBxwTA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

其中![\     \beta_{1},\beta_{2}   ](https://mmbiz.qpic.cn/mmbiz_png/75DkJnThACmbZyH56TS9jKRokzZHIsGCYdCZ5DfhUKZRicJ26jZGhicNKeDSqWM64RG4miafnDCPLbiaJQzetCicAIw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)是人工指定的参数，i为向量的分量下标。依靠这两个值构造参数的更新值，参数的更新公式为：

![img](https://mmbiz.qpic.cn/mmbiz_jpg/75DkJnThACmbZyH56TS9jKRokzZHIsGCSbCRaPN76BLBSzRvxGRrxZnEybB9IkXpLAJGVhBldFNzGJJ5j5a4oQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

在这里，用m代替梯度，用v来构造学习率。

 

NAG算法是一种凸优化方法，由Nesterov提出。和标准梯度下降法的权重更新公式类似，NAG算法构造一个向量v，初始值为0。v的更新公式为：

![img](https://mmbiz.qpic.cn/mmbiz_jpg/75DkJnThACmbZyH56TS9jKRokzZHIsGCco3BGTm45cl7Y2UR7bm2og4Kvzsx8JtxvgvjaAibPDoMut9qg6iave2A/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

参数的更新公式为：

![img](https://mmbiz.qpic.cn/mmbiz_jpg/75DkJnThACmbZyH56TS9jKRokzZHIsGCGc4ulyDATEg0ftLMbk3gFcxFHOhgPQCf81IMyTkO4rG8IeyNggrLGg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

与带动量项的SGD相比NAG只是计算梯度时用的参数值不同，NAG计算误差梯度时考虑了动量项，使用的是![img](https://mmbiz.qpic.cn/mmbiz_jpg/75DkJnThACmbZyH56TS9jKRokzZHIsGCLQvhR4fLeJN92skhedqRuxWQYtDaDa5sHibiaZILUic5JhwibAzDaEgvlw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)，其它都是一样的。

 

RMSProp算法[5]也是标准梯度下降法的变种，它由梯度值构造一个向量MS，初始化为0，更新公式为：

![img](https://mmbiz.qpic.cn/mmbiz_jpg/75DkJnThACmbZyH56TS9jKRokzZHIsGCx3cjSs3YyoUfZQvoJ1I9nEvVfFrg1omVQkBpibGoqdzKe2bfIibk2wOA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

参数更新公式为：

![img](https://mmbiz.qpic.cn/mmbiz_jpg/75DkJnThACmbZyH56TS9jKRokzZHIsGCGttmEbcfzBsM8avt8eBlia7GvQxjwkQrTecloAZZvyGW6WBYWlmn1qg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

其中![\     \delta   ](https://mmbiz.qpic.cn/mmbiz_png/75DkJnThACmbZyH56TS9jKRokzZHIsGC661laYe8sE22G5ujVypPA0ibMzccDtbrIxvqCtK1XmhrJoiawwHFrf0A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)是人工设定的参数。这种方法通过梯度的历史信息来生成参数更新值的权重系数。

随机梯度下降法

对于有些机器学习问题，我们的目标函数是对样本的损失函数。假设训练样本集有N个样本，训练时优化的目标是这个数据集上的平均损失函数：

![img](https://mmbiz.qpic.cn/mmbiz_jpg/75DkJnThACmbZyH56TS9jKRokzZHIsGCuqPL0BHlTiaQCh6LZrUANtdWxjoIxiaiaeKnNqUy3wVTf2S1Ob9JoKMrA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

其中![\    L(w,x_{i},y_{i})    ](https://mmbiz.qpic.cn/mmbiz_png/75DkJnThACmbZyH56TS9jKRokzZHIsGCuhnVbB0Iynmt8oGOexfmIvMsOnqu9vmTIC6Rx1bI2XNCnyqmAPMnrw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)是对单个训练样本![\     (x_{i},y_{i})   ](https://mmbiz.qpic.cn/mmbiz_png/75DkJnThACmbZyH56TS9jKRokzZHIsGCTw2nx2hKP1YlFEzmMSVDAn4P7BgeTtXPzFeegBgtss84H0Qc3wa9fQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)的损失函数，w是需要学习的参数。如果训练时每次都用所有样本计算梯度并更新，成本太高，作为改进可以在每次迭代时选取一批样本，将损失函数定义在这些样本上。

批量随机梯度下降法在每次迭代中使用上面目标函数的随机逼近值，即只使用![\     M\ll N   ](https://mmbiz.qpic.cn/mmbiz_png/75DkJnThACmbZyH56TS9jKRokzZHIsGCaLPiazAoea5Cr7EM9Cn2cicpThpibcmkPqrqHwxiaEuj701OxcCymkibKnw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)个样本来近似计算损失函数。在每次迭代时要优化的目标函数变为：

![img](https://mmbiz.qpic.cn/mmbiz_jpg/75DkJnThACmbZyH56TS9jKRokzZHIsGCbgISicCOOibd3cNKz1EomVgKNlbfsVOpGsaF2QP5kPrj9JkkjBGsPdSw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

已经证明，随机梯度下降法在数学期望的意义下收敛，即随机采样产生的梯度的期望值是真实的梯度。因为每次迭代时的目标函数实际上是不一样的，因此随机梯度下降法并不能保证每次迭代时函数值一定下降。